{% extends '::base.html.twig' %}

{% block title %}File list - Emission{% endblock %}

{% block javascripts %}
<script src="{{ asset('bundles/enginewerkemission/js/jquery-1.7.2.min.js') }}"></script>
<script src="{{ asset('bundles/enginewerkemission/js/vendor/resumable/resumable.js') }}"></script>
<script src="{{ asset('bundles/enginewerkemission/js/base.js') }}"></script>
<script src="{{ asset('bundles/enginewerkemission/js/md5.js') }}"></script>
<script src="{{ asset('bundles/enginewerkemission/js/vendor/SparkMD5/spark-md5.min.js') }}"></script>
{% endblock %}

{% block stylesheets %}
<link rel="stylesheet" href="{{ asset('bundles/enginewerkemission/css/style.css') }}">
<link rel="stylesheet" href="{{ asset('bundles/enginewerkemission/css/resumable.css') }}">
{% endblock %}

{% import '::macro.html.twig' as marco %}

{% block body %}
<!-- The fileinput-button span is used to style the file input field as button -->
    <!--<menu>Emission {{ app.user.username }}</menu>-->
    
    <div id="emissionFileDropContainer">
        <div id="dropbox">
            <div id="browse"></div>
        </div>
    </div>
    
    <div id="emissionFileListUploadContainer">
        <div id="dropbox_progress">
            <div class="progressHolder">
                <div class="progress"></div>
            </div>
        </div>
        
        <!-- The container for the uploaded files -->
        <div id="files" class="files">
            <table cellspacing="0" cellpadding="10" id="filesTable" class="center">
                <tbody>
            {% for File in Files %}
                <tr{% if File.isComplete == 1 %} data-file-completed="yes"{% endif%} data-file-id="{{ File.id }}">
                    <td class="fileName">{{ File.name }}{% if File.isComplete == 0 %} (incomplete){% endif %}</td>
                    <td class="fileUploadedBy">{{ File.uploadedBy }}</td>
                    <td class="fileHashID">{{ File.fileId }}</td>
                    <td class="fileType">{{ File.type }}</td>
                    <td class="fileSize">{{ marco.bytesToSize(File.size) }}</td>
                    <td class="fileExpirationDate">{{ File.expirationDate|date("Y-m-d H:i:s") }}</td>
                    <td class="fileUpdatedAt">{{ File.updatedAt|date("Y-m-d H:i:s") }}</td>
                    <td class="fileCreatedAt">{{ File.createdAt|date("Y-m-d H:i:s") }}</td>
                    {% if File.isComplete == 1 %}
                        <td class="fileOptions">
                            <a href="{{ path('show_file', {'file': File.fileId}) }}">show</a> 
                            <a href="{{ path('download_file', {'file': File.fileId}) }}" class="fileOptionsDownloadLink">save</a> 
                            <a href="{{ path('open_file', {'file': File.fileId}) }}" class="fileOptionsOpenLink">open</a> - 
                            <a href="{{ path('delete_file', {'file': File.fileId}) }}" class="remove-file" data-filename="{{ File.name }}">delete</a>
                        </td>
                    {% else %}
                        <td class="fileOptions"><a href="{{ path('delete_file', {'file': File.fileId}) }}">delete</a></td>
                    {% endif%}
                </tr>
            {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
    <p>
        <div id="emissionSettingsContainer">
            {% if app.environment == 'dev' %}
            <div>Chunk size: {{max_chunk_size}} M</div>
            <div><input type="checkbox" id="askBeforeDeleteCheckBox"/><label for="askBeforeDeleteCheckBox">Ask before delete</label></div>
            <div><input type="checkbox" id="fastAndStableNetworkCheckBox"/><label for="fastAndStableNetworkCheckBox">Fast network (LAN)</label></div>
            {% endif %}
        </div>
    </p>    
        
    <script type="text/javascript">
        var url = '{{ path('upload_file') }}'
        var urlChunkTest = '{{ path('upload_file_chunk_test') }}'
        var maxChunkSize = ({{max_chunk_size}} * 1024 * 1024); // to MB
        var postdata = {'form[_token]' : '{{Form._token.vars.value}}'};
        
        var pendingFilesNumber = 0;
        
        var r = new Resumable({
            target: url, 
            targetChunkTestUrl: urlChunkTest,
            chunkRetryInterval: 2,
            maxFileSize: 2147483648,
            simultaneousUploads: 1,
            method : 'POST',
            chunkSize : maxChunkSize,
            forceChunkSize : true,
            testChunks : true,
            query: postdata,
            fileParameterName : 'form[fileBlob]',
        });


        // Resumable.js isn't supported, fall back on a different method
        //if(!r.support) location.href = '/flash';

        r.assignBrowse(document.getElementById('browse'));
        r.assignDrop(document.getElementById('dropbox'));
        
 
        r.on('fileAdded', function(resumable) {

            var file = resumable.file;
            var fileNameHash = CryptoJS.MD5(file.fileName);

            r.upload();
            pendingFilesNumber++;
            
        var tableRow = '<tr id="fhash-' + fileNameHash + '"> \n' + 
            '<td class="fileName">' + file.fileName + '</td> \n' + 
            '<td class="fileHashID"></td> \n' + 
            '<td class="fileUploadedBy"></td> \n' + 
            '<td class="fileType"></td> \n' + 
            '<td class="fileSize">' + bytesToSize(file.size) + '</td> \n' + 
            '<td class="fileExpirationDate"></td> \n' + 
            '<td class="fileUpdatedAt"></td> \n' + 
            '<td class="fileCreatedAt"></td> \n' + 
            '<td></td> \n' + 
        '</tr>';

            $('#filesTable tbody').prepend(tableRow);
        });
        
        r.on('uploadStart', function(){
            cursorBusy();
        });
        
        r.on('fileSuccess', function(file, response) {

            log('Total files: ' + r.files.length);
            
            try {
                rsp = jQuery.parseJSON(response);
            } catch (error) {
                log('JSON parse error: ' + error);
                log(response);
            }

            if(rsp) {
                if(rsp.status === 'Success') {
                    if(rsp.data) {
                        
                        var file = rsp.data;
                        var link = $('<a>')
                        .attr('target', '_blank')
                        .prop('href', file.download_url);
                
                        var tableRow = '<tr data-file-id="' + file.id + '"> \n' + 
            '<td class="fileName">' + file.name + '</td> \n' + 
            '<td class="fileHashID">' + file.file_id + '</td> \n' + 
            '<td class="fileUploadedBy">' + file.uploaded_by + '</td> \n' + 
            '<td class="fileType">' + file.type + '</td> \n' + 
            '<td class="fileSize">' + bytesToSize(file.size) + '</td> \n' + 
            '<td class="fileExpirationDate">' + file.expiration_date + '</td> \n' + 
            '<td class="fileUpdatedAt">' + file.updated_at + '</td> \n' + 
            '<td class="fileCreatedAt">' + file.created_at + '</td> \n' + 
            '<td class="fileOptions"><a href="' + file.show_url + '">show</a> <a href="' + file.download_url + '" class="fileOptionsDownloadLink">save</a> <a href="' + file.open_url + '" class="fileOptionsOpenLink">open</a> - <a href="' + file.delete_url + '" class="remove-file">delete</a></td> \n' + 
        '</tr>';

                        $('#fhash-' + CryptoJS.MD5(file.name) + '').replaceWith(tableRow);
                        
                        pendingFilesNumber--;

                        if(pendingFilesNumber === 0) {
                            
                            cursorNormal();
                            setTimeout(function() {
   
                                $('#dropbox_progress div.progressHolder').fadeTo(200, 0.01, function(){
                                    setTimeout(function(){
                                        $('#dropbox_progress').find('.progress').width(0);
                                        setTimeout(function(){
                                            $('#dropbox_progress div.progressHolder').fadeTo(100, 1);
                                        }, 200);
                                    }, 300);
                                });
                             }, 100);
                        }

                    } else {
                        log("Chunk uploaded");
                    }

                } else {
                    if(rsp.status === 'Error') {
                        if(rsp.data.message) {
                            alert('Error occured: ' + rsp.data.message);
                        } else {
                            alert('Unexpectred error occured');
                        }
                    } else {
                        alert('Unexpectred error occured');
                    }
                }
            } else {
                alert('Unexpectred error occured');
            } 
        });
        
        r.on('fileError', function(file, message){
            log('fileError');
            alert('General sending error');
            cursorNormal();
        });

        r.on('progress', function(event) {
            $('#dropbox_progress').find('.progress').width($('#dropbox_progress').find('.progressHolder').width() * r.progress());
        });
        
        // IMAGE PASTE
        // We start by checking if the browser supports the 
        // Clipboard object. If not, we need to create a 
        // contenteditable element that catches all pasted data 
        if (!window.Clipboard) {
           var pasteCatcher = document.createElement("div");

           // Firefox allows images to be pasted into contenteditable elements
           pasteCatcher.setAttribute("contenteditable", "");

           // We can hide the element and append it to the body,
           pasteCatcher.style.opacity = 0;
           document.body.appendChild(pasteCatcher);

           // as long as we make sure it is always in focus
           //pasteCatcher.focus();
           document.addEventListener("click", function() { pasteCatcher.focus(); });
        } 

        // Add the paste event listener
        window.addEventListener("paste", pasteHandler);

        /* Handle paste events */
        function pasteHandler(e) {
           // We need to check if event.clipboardData is supported (Chrome)
           if (e.clipboardData) {
              // Get the items from the clipboard
              var items = e.clipboardData.items;
              if (items) {
                 // Loop through all items, looking for any kind of image
                 for (var i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf("image") !== -1) {
                       // We need to represent the image as a file,
                       var file = items[i].getAsFile();
                       // and use a URL or webkitURL (whichever is available to the browser)
                       // to create a temporary URL to the object
                       //var URLObj = window.URL || window.webkitURL;
                       //var source = URLObj.createObjectURL(blob);

                       // The URL can then be used as the source of an image
                       var d = new Date();
                       file.name = 'Screenshot ' + d.toString();
                       r.addFile(file);
                    }
                 }
              }
           // If we can't handle clipboard data directly (Firefox), 
           // we need to read what was pasted from the contenteditable element
           } else {
              // This is a cheap trick to make sure we read the data
              // AFTER it has been inserted.
              setTimeout(checkInput, 1);
           }
        }

        /* Parse the input in the paste catcher element */
        function checkInput() {
           // Store the pasted content in a variable
           var child = pasteCatcher.childNodes[0];

           // Clear the inner html to make sure we're always
           // getting the latest inserted content
           pasteCatcher.innerHTML = "";

           if (child) {
              // If the user pastes an image, the src attribute
              // will represent the image as a base64 encoded string.
              if (child.tagName === "IMG") {
                 createImage(child.src);
              }
           }
        }

        /* Creates a new image from a given source */
        function createImage(source) {
           var pastedImage = new Image();
           pastedImage.onload = function() {

                // atob to base64_decode the data-URI
                var image_data = atob(pastedImage.src.split(',')[1]);
                // Use typed arrays to convert the binary data to a Blob
                var arraybuffer = new ArrayBuffer(image_data.length);
                var view = new Uint8Array(arraybuffer);
                for (var i=0; i<image_data.length; i++) {
                    view[i] = image_data.charCodeAt(i) & 0xff;
                }

                try {
                    // This is the recommended method:
                    var blob = new Blob([arraybuffer], {type: 'application/octet-stream'});
                } catch (e) {
                    // The BlobBuilder API has been deprecated in favour of Blob, but older
                    // browsers don't know about the Blob constructor
                    // IE10 also supports BlobBuilder, but since the `Blob` constructor
                    //  also works, there's no need to add `MSBlobBuilder`.
                    var bb = new (window.WebKitBlobBuilder || window.MozBlobBuilder);
                    bb.append(arraybuffer);
                    var blob = bb.getBlob('application/octet-stream'); // <-- Here's the Blob    
                }

                var d = new Date();
                blob.name = 'Screenshot' + d.toString();
                r.addFile(blob);
           };

           pastedImage.src = source;
        }
        
        
        function bytesToSize(bytes) {
            if (bytes === 0)
                return 'n/a';
            
            var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            var i = parseInt(Math.floor(Math.log(bytes) / Math.log(1024)));
            
            return Math.round(bytes / Math.pow(1024, i), 2) + ' ' + sizes[[i]];
        };
    </script>
{% endblock %}

